#TODO have the battle_coordinator hold on to a single copy of each AI type it needs, so individual units don't need to hold them
#TODO units have a list of AI types in order of priority [eg "swarmer" falls back to "random"]
#TODO AI can call other AI to change behaviors under certian conditions

#TODO An AI needs to be able to reply back that it has no valid targets so that the coordinator can check the next lowest AI

#TODO battle_coordinator creates a separate battle_data module so the code's cleaner

*Swarming* needs a target list made of units attacked by the same unit type as it
This means the coordinator needs to keep track of the names of units that attack other units (a dict?), 
then filter it down to units attacked by *Swarming_unit.name* 
- needs a fallback when it's the last bug standing

*Vengeful* needs the unit that attacked it for the most damage
Coordinator needs to keep track of which unit does how much damage to whom, 
including a running total
[*Focused*]

Random can 'see' all enemy units, 
so AI which need enemies' stats are already covered as far as coordinator cares:
[*Vicious*, *Bully*, *Slayer*]

*Efficient*: ???

*Mindful*: (I think I misunderstood the assignment.) 
In No-Init mode, targets almost like an anti-vicious: 
    the lowest-health enemy that has current hp higher than any of *mindful*'s teammates min_attack. 
In Init Mode, if less inteligent allies are likely to kill an enemy before *mindful* can act, 
then the enemy will be dead, and *mindful* has to calculate based on some other principle.

If you mean it queries each ally's AI to see what the ally will do on it's turn, 
then making decisions based on that, well... 
I'm getting chess AI vibes. 
Some kind of neural net, maybe? 
An __Actual AI__.

Using our current setup of just hp and a variable amount of damage, *Mindful* needs to find the best unit to attack on a given turn. 
Each round needs to find the best response to one of up to `(n*a)^2e + (n*e)^2a` posibilities,
where "a" is the number of units on *Mindful's* team, and "e" the number of enemy units, 
with the two forks of each step being whether the unit kills it's target. 
Knowing what AI a unit is using reduces "a" or "e" in the exponent, 
because you know their actual target list,
but you make each step harder by some factor "n" as you ask or predict the AI's behavior.
Mindful can't ask or predict another Mindful, because it makes an infinite loop and is an example of the Halting Problem.

[Technically, you could say it's "just" `(na)^2e` posibilities, but this ignores the fact that you are usually unlikely to kill someone if they've killed you first.]

REJECT PILE 
# have AI pass back a curated list of targets, and if that's empty, the original list
# having curated the list, why not just act?